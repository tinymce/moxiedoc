export interface PageOutput {
  readonly type: 'adoc' | 'json';
  readonly filename: string;
  readonly content: string;
}

// TODO: we can pass this through later
const baseURL = '';

const hasValue = <T>(x: T): x is NonNullable<T> => {
  // empty helper for strings, objects, arrays
  if (typeof x === 'string' || Array.isArray(x)) {
    return x.length > 0;
  } else if (typeof x === 'object') {
    return Object.keys(x).length > 0;
  } else {
    return false;
  }
};

// uppercase first char
const uppercaseFirstChar = (str: string): string =>
  str.charAt(0).toUpperCase() + str.slice(1);

// escape comments from breaking asciidoc
const escapeComments = (str: string): string =>
  str.replace(/<!--/, '&lt;!--').replace(/-->/, '--&gt;');

// convert BRs found into asciidoc \n
const encodeBR = (str: string): string =>
  str.replace(/<br\s*\/?>/g, '\n');

// convert <em> into _italics_ asciidoc
const encodeEM = (str: string): string =>
  str.replace(/<\/?em>/g, '_');

// convert <code> into backtick asciidoc
const encodeCode = (str: string) => {
  const regex = /<code>(.*?)<\/code>/g;
  let matches;
  while ((matches = regex.exec(str))) {
    str = str.replace(matches[0], '`' + matches[1] + '`').replace('"`', '`').replace('`"', '`');
  }
  return str;
};

// runs a bunch of required cleanup filters, where embedded code/text can break asciidoc rendering
const cleanFilter = (str: string): string => {
  const filters = [ escapeComments, encodeBR, encodeEM, encodeLinks, encodeCode ];
  return filters.reduce((acc, filter) => filter(acc), str);
};

// convert <a href> into asciidoc link
const encodeLinks = (str: string): string => {
  const matches = /[^<]*(<a href="([^"]+)">([^<]+)<\/a>)/.exec(str);
  if (matches !== null) {
    const asciidoc = 'link:' + matches[2] + '[' + matches[3] + ']';
    return str.replace(matches[1], asciidoc);
  } else {
    return str;
  }
};

const convert = (pages: PageOutput[][]): PageOutput[][] => pages.map((page) => {
  // page[0] is json
  // page[1] is adoc
  const data = JSON.parse(page[0].content);
  let tmp = page[1].content;

  // map structure generated by template.js
  // data.datapath = string
  // data.desc = string
  // data.constructors = []
  // data.methods = []
  // data.properties = []
  // data.settings = []
  // data.events = []
  // data.keywords = []
  // data.borrows = data.borrows || []
  // data.examples = data.examples || []

  // summary
  if (hasValue(data.summary)) {
    tmp += data.summary + '\n';
  }

  // borrows
  // untested snipped, no class extends data
  if (hasValue(data.borrows)) {
    tmp += '[[extends]]\n';
    tmp += '\n== Extends\n';
    data.borrows.forEach((item) => {
      tmp += 'link:' + baseURL + item + '[' + item + ']\n';
    });
  }

  // examples
  if (hasValue(data.examples)) {
    tmp += '[[examples]]\n';
    tmp += '\n== Examples\n';
    data.examples.forEach((example) => {
      tmp += '[source, javascript]\n';
      tmp += '----\n';
      tmp += example.content + '\n';
      tmp += '----\n';
    });
  }

  // settings
  // untested snippet, no settings data
  if (hasValue(data.settings)) {
    tmp += '[[settings]]\n';
    tmp += '\n== Settings\n';

    tmp += '[options="header"]\n';
    tmp += '|===\n';
    tmp += '|Name|Type|Summary|Defined by\n';

    data.settings.forEach((item) => {
      tmp += '|' + item.name;
      if (item.dataTypes[0].includes('tinymce', 0)) {
        tmp += '|link:' + baseURL + item.dataTypes[0] + '.html[' + item.dataTypes[0] + ']';
      } else {
        tmp += '|' + item.dataTypes[0];
      }
      tmp += '|' + item.desc;
      tmp += '|link:' + baseURL + item.definedBy + '.html[' + item.definedBy + ']\n';
    });
    tmp += '|===\n';
  }

  // properties
  if (hasValue(data.properties)) {
    tmp += '[[properties]]\n';
    tmp += '\n== Properties\n';

    tmp += '[options="header"]\n';
    tmp += '|===\n';
    tmp += '|Name|Type|Summary|Defined by\n';

    data.properties.forEach((item) => {
      tmp += '|' + item.name;

      if (item.dataTypes[0].includes('tinymce', 0)) {
        tmp += '|`link:' + baseURL + item.dataTypes[0] + '.html[' + item.dataTypes[0] + ']`';
      } else {
        tmp += '|`' + item.dataTypes[0] + '`';
      }

      tmp += '|' + cleanFilter(item.desc);
      tmp += '|link:' + baseURL + item.definedBy + '.html[' + item.definedBy + ']\n';
    });
    tmp += '|===\n';
  }

  // constructors - basic summary
  if (hasValue(data.constructors)) {
    tmp += '[[constructors]]\n';
    tmp += '\n== Constructors\n';

    tmp += '[options="header"]\n';
    tmp += '|===\n';
    tmp += '|Name|Summary|Defined by\n';

    data.constructors.forEach((item) => {
      tmp += '|link:#' + item.name + '[' + item.name + '()]';
      tmp += '|' + item.desc;
      tmp += '|link:' + baseURL + item.definedBy + '.html[' + item.definedBy + ']\n';
    });
    tmp += '|===\n';
  }

  // methods - basic summary
  if (hasValue(data.methods)) {
    tmp += '[[' + data.name + ']]\n';
    tmp += '\n== ' + data.name + ' Reference\n';
    tmp += '[options="header"]\n';
    tmp += '|===\n';
    tmp += '|Name|Summary|Defined by\n';
    data.methods.forEach((item) => {
      tmp += '|link:#' + item.name + '[' + item.name + '()]|' + cleanFilter(item.desc) + '|link:' + baseURL + item.definedBy + '.html[' + item.definedBy + ']\n';
    });
    tmp += '|===\n';
  }

  // events - basic summary
  // untested snippet, no events data
  if (hasValue(data.events)) {
    tmp += '[[events]]\n';
    tmp += '\n== Events\n';

    tmp += '[options="header"]\n';
    tmp += '|===\n';
    tmp += '|Name|Summary|Defined by\n';

    data.events.forEach((item) => {
      tmp += '|link:#' + item.name + '[' + item.name + '()]';
      tmp += '|' + item.desc;
      tmp += '|link:' + baseURL + item.definedBy + '.html[' + item.definedBy + ']\n';
    });
    tmp += '|===\n';
  }

  // constructors 2 - enhanced detail
  if (hasValue(data.constructors)) {

    tmp += '\n== Constructors\n';

    data.constructors.forEach((constructor) => {
      tmp += '[[' + constructor.name + ']]\n';
      tmp += '\n=== link:#' + constructor.name + '[' + constructor.name + ']\n';
      tmp += '`' + constructor.signature + '` ';
      tmp += constructor.desc + '\n';
      if (hasValue(constructor.examples)) {
        tmp += '\n===== Examples';
        constructor.examples.forEach((example) => {
          tmp += '[source, javascript]\n';
          tmp += '----\n';
          tmp += example.content + '\n';
          tmp += '----\n';
        });
        tmp += '\n';
      }
      if (hasValue(constructor.params)) {
        tmp += '\n===== Parameters';
        constructor.params.forEach((param) => {
          tmp += '\n* `' + param.name;
          if (param.types[0].includes('tinymce', 0)) {
            tmp += ' link:' + baseURL + param.types[0] + '.html[' + param.types[0] + ']`';
          } else {
            tmp += ': ' + param.types[0] + '`';
          }
          tmp += '\n';
        });
        tmp += '\n';
      }

      if (hasValue(constructor.return) && hasValue(constructor.return.types)) {
        // untested - no data
        constructor.return.types.forEach((type) => {
          if (type.includes('tinymce', 0)) {
            tmp += '\n* `link:' + baseURL + type + '.html[' + type + ']`';
          } else {
            tmp += '\n* `' + type + '`';
          }
          tmp += ' - ' + constructor.return.desc + '\n';
        });
        tmp += '\n';
      }
    });
  }

  // methods 2 - enhanced details
  if (hasValue(data.methods)) {
    tmp += '\n== Methods\n';
    data.methods.forEach((method) => {
      tmp += '[[' + method.name + ']]\n';
      tmp += '\n=== ' + method.name + '()\n';
      tmp += '[source, javascript]\n';
      tmp += '----\n';
      tmp += method.signature + '\n';
      tmp += '----\n';
      tmp += cleanFilter(method.desc) + '\n';

      if (hasValue(method.examples)) {
        tmp += '\n==== Examples\n';
        method.examples.forEach((example) => {
          tmp += '[source, javascript]\n';
          tmp += '----\n';
          tmp += example.content + '\n';
          tmp += '----\n';
        });
      }

      if (hasValue(method.params)) {
        tmp += '\n==== Parameters\n';
        method.params.forEach((param) => {
          tmp += '\n* `' + param.name;
          if (param.types[0].includes('tinymce', 0)) {
            tmp += ' link:' + baseURL + param.types[0] + '.html[' + param.types[0] + ']`';
          } else {
            tmp += ' (' + uppercaseFirstChar(param.types[0]) + ')`';
          }
          tmp += ' - ' + cleanFilter(param.desc) + '\n';
        });
      }

      if (hasValue(method.return) && hasValue(method.return.types)) {
        tmp += '\n==== Return value\n';
        method.return.types.forEach((type) => {
          tmp += '\n* `';
          if (type.includes('tinymce', 0)) {
            tmp += 'link:' + baseURL + type + '.html[' + type + ']`';
          } else {
            tmp += '(' + uppercaseFirstChar(type) + ')`';
          }
          tmp += ' - ' + method.return.desc + '\n';
        });
      }

      tmp += `\n'''\n`;
    });
  }

  // events 2 - enhanced details
  // untested snippet, no events data
  if (hasValue(data.events)) {
    tmp += '\n== Events\n';
    data.events.forEach((event) => {
      tmp += '[[' + event.name + ']]\n';
      tmp += '\n=== ' + event.name + '()\n';
      tmp += event.desc + '\n';

      if (hasValue(event.params)) {
        tmp += '\n==== Parameters\n';
        event.params.forEach((param) => {
          tmp += '\n* `' + param.name;
          if (param.types[0].includes('tinymce', 0)) {
            tmp += ' link:' + baseURL + param.types[0] + '.html[' + param.types[0] + ']`';
          } else {
            tmp += ' (' + uppercaseFirstChar(param.types[0]) + ')`';
          }
          tmp += ' - ' + param.desc;
          tmp += '\n';
        });
      }
    });
  }

  // return the applied antora page mutation
  page[1] = {
    ...page[1],
    content: tmp
  };
  return page;
});

export {
  convert
};
