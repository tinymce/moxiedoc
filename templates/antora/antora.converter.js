module.exports = function () {

  // Todo we can pass this through later
  var baseurl = '';

  function hasValue (x) {
    // empty helper for strings, objects, arrays
    if (typeof(x) === 'string' || typeof(x) === 'array') {
      return x.length > 0
    } else if (typeof(x) === 'object') {
      return Object.keys(x).length > 0
    } else {
      return false;
    }
  };

  // runs a bunch of required cleanup filters, where embedded code/text can break asciidoc rendering
  function cleanFilter (string) {
    return encodeCode(encodeLinks(encodeEM(encodeBR(escapeComments(string)))));
  };

  // escape comments from breaking asciidoc
  function escapeComments(str) {
    return str.replace(/<!--/,'&lt;!--').replace(/-->/,'--&gt;') ;
  }
  // convert BRs found into asciidoc
  function encodeBR(str) {
    return str.replace(/<br\s*\/?>/g,'\n');
  }
  // convert <em> into italics
  function encodeEM(str) {
    return str.replace(/<em>/,'_').replace(/<\/em>/, '_');
  }
  // convert <em> into italics
  function encodeCode(str) {
    var regex = /<code>(.*?)<\/code>/g;
    var matches;
    while (matches = regex.exec(str)) {
      str = str.replace(matches[0], '`' + matches[1] + '`').replace('"`', '`').replace('`"', '`');
    }
    return str
  }
  // convert <a href> into italics
  function encodeLinks(str) {
    var matches = str.match('[^<]*(<a href="([^"]+)">([^<]+)<\/a>)');
    if (matches !== null) {
      var asciidoc = 'link:' + matches[2] + '[' + matches[3] + ']';
      return str.replace(matches[1], asciidoc)
    } else {
      return str
    }
  }

  function convert(memberData) {
    return memberData.map(function (page) {
      // page[0] is json
      // page[1] is adoc
      var data = JSON.parse(page[0].content);
      var tmp = page[1].content;
      
      // map structure generated by template.js
      // data.datapath = string
      // data.desc = string
      // data.constructors = []
      // data.methods = []
      // data.properties = []
      // data.settings = []
      // data.events = []
      // data.keywords = []
      // data.borrows = data.borrows || []
      // data.examples = data.examples || []

      // summary
      if (hasValue(data.summary)) {
        tmp += data.summary + '\n';
      }

      // borrows
      // untested snipped, no class extends data
      if (hasValue(data.borrows)) {
        tmp += '[[extends]]\n';
        tmp += '\n== Extends\n';
        data.borrows.forEach(item => {
          tmp += 'link:' + baseurl + '/api/' + item + '[' + item + ']\n'
        });
      }

      // examples
      if (hasValue(data.examples)) {
        tmp += '[[examples]]\n';
        tmp += '\n== Examples\n';
        data.examples.forEach(example => {
          tmp += '[source, javascript]\n';
          tmp += '----\n';
          tmp += example.content + '\n';
          tmp += '----\n';
        });
      }

      // settings
      // untested snippet, no settings data
      if (hasValue(data.settings)) {
        tmp += '[[settings]]\n';
        tmp += '\n== Settings\n';
        
        tmp += '[options="header"]\n'
        tmp += '|===\n'
        tmp += '|Name|Type|Summary|Defined by\n'

        data.settings.forEach(item => {
          tmp += '|' + item.name;
          if (item.dataTypes[0].includes('tinymce', 0)) {
            tmp += '|link:' + baseurl + '/apis/' + item.dataTypes[0] + '[' + item.dataTypes[0] + ']';
          } else {
            tmp += '|' + item.dataTypes[0];    
          }
          tmp += '|' + item.desc;
          tmp += '|link:' + baseurl + '/apis/' + item.definedBy + '[' + item.definedBy + ']\n';
        })
        tmp += '|===\n';
      }

      // properties
      if (hasValue(data.properties)) {
        tmp += '[[properties]]\n';
        tmp += '\n== Properties\n';

        tmp += '[options="header"]\n'
        tmp += '|===\n'
        tmp += '|Name|Type|Summary|Defined by\n'
      
        data.properties.forEach(item => {
          tmp += '|' + item.name;
          
          if (item.dataTypes[0].includes('tinymce', 0)) {
            tmp += '|`link:' + baseurl + '/apis/' + item.dataTypes[0] + '[' + item.dataTypes[0] + ']`';
          } else {
            tmp += '|`' + item.dataTypes[0] + '`';
          }
    
          tmp += '|' + cleanFilter(item.desc);
          tmp += '|link:' + baseurl + '/apis/' + item.definedBy + '[' + item.definedBy + ']\n';
        })
        tmp += '|===\n';
      }

      // constructors - basic summary
      if (hasValue(data.constructors)) {
        tmp += '[[constructors]]\n';
        tmp += '\n== Constructors\n';

        tmp += '[options="header"]\n'
        tmp += '|===\n'
        tmp += '|Name|Summary|Defined by\n'

        data.constructors.forEach(item => {
          tmp += '|link:#' + item.name + '[' + item.name + '()]';
          tmp += '|' + item.desc;
          tmp += '|link:' + baseurl + '/apis/' + item.definedBy + '[' + item.definedBy + ']\n';
        });
        tmp += '|===\n'
      }

      // methods - basic summary
      if (hasValue(data.methods)) {
        tmp += '[[' + data.name + ']]\n';
        tmp += '\n== ' + data.name + ' Reference\n';
        tmp += '[options="header"]\n'
        tmp += '|===\n'
        tmp += '|Name|Summary|Defined by\n'
        data.methods.forEach(item => {
          tmp += '|link:#' + item.name + '[' + item.name + '()]|' + cleanFilter(item.desc) + '|link:' + baseurl + '/apis/' + item.definedBy + '[' + item.definedBy + ']\n';
        });
        tmp += '|===\n'
      }

      // events - basic summary
      // untested snippet, no events data
      if (hasValue(data.events)) {
        tmp += '[[events]]\n';
        tmp += '\n== Events\n';

        tmp += '[options="header"]\n'
        tmp += '|===\n'
        tmp += '|Name|Summary|Defined by\n'

        data.events.forEach(item => {
          tmp += '|link:#' + item.name + '[' + item.name + '()]';
          tmp += '|' + item.desc;
          tmp += '|link:' + baseurl + '/apis/' + item.definedBy + '[' + item.definedBy + ']\n';
        });
        tmp += '|===\n'
      }

      // constructors 2 - enhanced detail
      if (hasValue(data.constructors)) {

        tmp += '\n== Constructors\n';

        data.constructors.forEach(constructor => {
          tmp += '[[' + constructor.name + ']]\n';
          tmp += '\n=== link:#' + constructor.name + '[' + constructor.name + ']\n';
          tmp += '`' + constructor.signature + '` ';
          tmp += constructor.desc + '\n';
          if (hasValue(constructor.examples)) {
            tmp += '\===== Examples';
            constructor.examples.forEach(example => {
              tmp += '[source, javascript]\n';
              tmp += '----\n';
              tmp += example.content + '\n';
              tmp += '----\n';
            })
            tmp += '\n';
          }
          if (hasValue(constructor.params)) {
            tmp += '\n===== Parameters';
            constructor.params.forEach(param => {
              tmp += '\n* `' + param.name;
              if (param.types[0].includes('tinymce', 0)) {
                tmp += ' link:' + baseurl + '/apis/' + param.types[0] + '[' + param.types[0] + ']`';
              } else {
                tmp += ': ' + param.types[0] + '`';    
              }
              tmp += '\n';
            })
            tmp += '\n';
          }

          if (hasValue(constructor.return) && hasValue(constructor.return.types)) {
            // untested - no data
            constructor.return.types.forEach(type => {
              if (type.includes('tinymce', 0)) {
                tmp += '\n* `link:' + baseurl + '/apis/' + type + '[' + type + ']`';
              } else {
                tmp += '\n* `' + type + '`';
              }
              tmp += ' - ' + constructor.return.desc + '\n'
            });
            tmp += '\n';
          };
        });
      }

      // methods 2 - enhanced details
      if (hasValue(data.methods)) {
        tmp += '\n== Methods\n';
        data.methods.forEach(method => {
          tmp += '[[' + method.name + ']]\n';
          tmp += '\n=== ' + method.name + '()\n';
          tmp += '[source, javascript]\n';
          tmp += '----\n';
          tmp += method.signature + '\n';
          tmp += '----\n';
          tmp += method.desc + '\n';
          
          if (hasValue(method.examples)) {
            tmp += '==== Examples\n';
            method.examples.forEach(example => {
              tmp += '[source, javascript]\n';
              tmp += '----\n';
              tmp += example.content + '\n';
              tmp += '----\n';
            });
          }
          if (hasValue(method.params)) {
            tmp += '\n==== Parameters\n';
            method.params.forEach(param => {
              tmp += '\n* `' + param.name;
              if (param.types[0].includes('tinymce', 0)) {
                tmp += ' link:' + baseurl + '/apis/' + param.types[0] + '[' + param.types[0] + ']`';
              } else {
                tmp += ' (' + param.types[0] + ')`';
              }
              tmp += ' - ' + param.desc + '\n';
            })
          }
          if (hasValue(method.return) && hasValue(method.return.types)) {
            tmp += '\n==== Return value\n';
            method.return.types.forEach(type => {
              tmp += '\n* `';
              if (type.includes('tinymce', 0)) {
                tmp += 'link:' + baseurl + '/apis/' + type + '[' + type + ']`';
              } else {
                tmp += '(' + type + ')`';
              }
              tmp += ' - ' + method.return.desc  + '\n';
            });
          }

          tmp += "\n'''\n";
        });
      }

      // events 2 - enhanced details
      // untested snippet, no events data
      if (hasValue(data.events)) {
        tmp += '\n== Events\n';
        data.events.forEach(event => {
          tmp += '[[' + event.name + ']]\n';
          tmp += '\n=== ' + event.name + '()\n';
          tmp += event.desc + '\n';
        });
        if (hasValue(method.params)) {
          tmp += '\n===== Parameters\n';
          method.params.forEach(param => {
            tmp += '\n* `' + param.name;
            if (param.types[0].includes('tinymce', 0)) {
              tmp += ' link:' + baseurl + '/apis/' + param.types[0] + '[' + param.types[0] + ']`';
            } else {
              tmp += ' (' + param.types[0] + ')`';
            }
            tmp += ' - ' + param.desc 
            tmp += '\n';
          })
        }
      }

      // return the applied antora page mutation
      page[1].content = tmp
      return page;
    })
  }

  return {
    convert: convert
  }
}();